# Auth API — README

**Project**
- **Name**: Auth API for the backend project.
- **Description**: Authentication endpoints using Firebase ID tokens, JWT access tokens, and rotating refresh tokens (stored hashed via Argon2). Routes mounted under `/api/v1/login`.

**Quick Start**
- **Install**: `npm install`
- **Run (dev)**: `npm run dev`
- **Build + Start**: `npm run build` then `npm start`

**Environment**
- **Required**:
  - `JWT_SECRET`: Secret used to sign access tokens (HS256). Keep secure.
  - `FIREBASE_PROJECT_ID`: Firebase service account project id.
  - `FIREBASE_CLIENT_EMAIL`: Firebase service account client email.
  - `FIREBASE_PRIVATE_KEY`: Firebase private key (use `\n`-escaped newlines if needed).
  - `DATABASE_HOST`, `DATABASE_USER`, `DATABASE_PASSWORD`, `DATABASE_NAME`: Database connection (Prisma MariaDB adapter).
- **Optional**:
  - `PORT`: Server port (default `3000`).

**Where to look in code**
- **Routes**: [src/modules/auth/auth.route.ts](src/modules/auth/auth.route.ts)
- **Controllers**: [src/modules/auth/auth.controller.ts](src/modules/auth/auth.controller.ts), [src/modules/auth/auth.refresh.controller.ts](src/modules/auth/auth.refresh.controller.ts)
- **Service logic**: [src/modules/auth/auth.service.ts](src/modules/auth/auth.service.ts)
- **Refresh token helpers**: [src/utils/refreshToken.ts](src/utils/refreshToken.ts)
- **Auth middleware**: [src/middlewares/auth.middleware.ts](src/middlewares/auth.middleware.ts)

**Endpoints (base path: `/api/v1/login`)**

- **POST /google**
  - **Description**: Accepts a Firebase ID token from client sign-in (Google). Verifies token, creates/updates user.
  - **Request body**: `{ "idToken": "<firebase-id-token>" }`
  - **Responses**:
    - `200 { "step": "VERIFY_MOBILE" }` — user exists but mobile not verified; client should prompt phone verify flow.
    - `200 { "step": "LOGIN", "tokens": { "accessToken", "refreshToken" } }` — login success.
    - `400` / `401` — missing or invalid token.
  - **Notes**: Access token expires ~15 minutes; refresh token expires ~7 days and is rotated on use.

- **POST /verify-otp**
  - **Description**: After phone verification via Firebase, sends Firebase ID token containing phone number to mark mobile verified and issue tokens.
  - **Request body**: `{ "idToken": "<firebase-id-token>" }`
  - **Response**: `200 { "step": "LOGIN", "tokens": { "accessToken", "refreshToken" } }`

- **POST /refresh-token**
  - **Description**: Rotate and exchange a valid refresh token for a new access token and a new refresh token.
  - **Request body**: `{ "refreshToken": "<refresh-token>" }`
  - **Response**: `200 { "accessToken": "...", "refreshToken": "..." }` or `401` if invalid.
  - **Security**: Server stores refresh token hashes (Argon2); endpoint finds matching hashed token and rotates it.

**Using Access Tokens**
- **Include access token**: Use HTTP header `Authorization: Bearer <accessToken>` for protected routes.
- **Middleware**: `authMiddleware` verifies token signature, ensures `tokenType === "access"`, and attaches decoded payload to `req.user`.

**Examples (cURL)**
- Login with Google ID token:

```bash
curl -X POST http://localhost:3000/api/v1/login/google \
  -H "Content-Type: application/json" \
  -d '{"idToken":"<FIREBASE_ID_TOKEN>"}'
```

- Refresh tokens:

```bash
curl -X POST http://localhost:3000/api/v1/login/refresh-token \
  -H "Content-Type: application/json" \
  -d '{"refreshToken":"<REFRESH_TOKEN>"}'
```

- Call protected API example:

```bash
curl http://localhost:3000/api/v1/protected-route \
  -H "Authorization: Bearer <ACCESS_TOKEN>"
```

**Implementation notes & behavior**
- Access tokens are JWTs signed with `JWT_SECRET` and contain `tokenType: "access"`.
- Refresh tokens are random hex strings generated by `crypto.randomBytes` and stored hashed using Argon2.
- On refresh, refresh tokens are rotated (old token deleted, new token stored hashed).
- Token durations: access ~15m, refresh ~7 days (hard-coded in service/controller).

**Next steps**
- Add endpoints for logout (delete refresh tokens) if desired.
- Consider storing refresh tokens with device metadata to support multiple devices.